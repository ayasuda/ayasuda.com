僕の考えた最強の Markdown パーサ
====

~どうしても自前文法を markdown に入れたいなら、結局パーサ作るしかないよね。~

抽象構文木が作れるならこれで勝つる！

一般的なコンパイラは

1. 字句解析
2. 構文解析
3. コード生成

の流れで進みます。

このうち、字句解析と構文解析の結果できる抽象構文木 (abstract syntax tree, AST) が作れれば、そこから HTML に変換するのは簡単です。

さて、字句解析器は lex で、構文解析器を作るのは yacc が歴史的によく使われていました。

練習用に lex + yacc で簡単なパーサを作ってみる
----

### lex で字句解析をしてみる

lex (a lexical analyser generator) は字句解析器を作るツールです。
字句解析器とは与えられたテキストを、トークン、つまり意味のある単位ごとに分解する機械です。

まずは簡単に、複数行の英語文書が与えられた時に行数、単語数、文字数を数える簡単なプログラムを書いてみましょう。

```console
$ echo "foo" | mywc
# of lines = 1, # of words = 1, # of chars = 3
```

lex のプログラムは定義部・規則部・Cコード部の３つのブロックでできおり、それぞれの領域は `%%` で区切られます。

```lex
// ここは定義部

%%

// ここは規則部

%%

// ここはCコード部
```

定義部には lex 向けのオプション設定や、全体で使われるソースコード、例えば変数や関数の宣言などを書きます。

規則部には字句解析のための規則を書きます。この際、正規表現を用いて様々なルールを設定していきます。

Cコード部には、規則部で使う関数の実装を書きます。lex で作ったプログラムを単体で動かす場合には main 関数もここに書きます。

さて、今回組むコードは yacc と組み合わせず、lex で作った解析器を単体で使います。
その場合には、 lex 向けのオプション `%option noyywrap` を設定してやる必要があります。
また、与えられたテキストをもとに行数、単語数、文字数を数えます。
ですので、カウンター用の変数を定義部で宣言し、初期化する必要があります。
定義部では C のコードを書く際に、 `%{` と `%}` で囲ってやる必要があります。

ここまでをコード(ファイル名を mywc.l とします)にすると次の通りです。

```lex:mywc.l
%option noyywrap
%{
  int num_lines = 0, num_words =0 ,num_chars = 0;
%}

%%

%%
```

規則部では正規表現を用いて字句解析のための規則を記していきます。
書き方は簡単で、１行にパターンを書き、次にアクションを書きます。
アクションは C のプログラムコードで書き、1文ならそのまま、2文以上なら `{}` で囲んで書きます。

サンプルを示しましょう。簡単な正規表現を使い、それぞれ改行、単語、文字をそれぞれカウントしています。

```lex:mywc.l
%option noyywrap
%{
  int num_lines = 0, num_words =0 ,num_chars = 0;
%}

%%

\n        { ++num_lines; ++num_chars }
[A-Za-z]* ++num_words;
.         ++num_chars;

%%
```

Cコード部では、規則部で使う関数の実装などを書きますが、今回は関数を特に使っていません。
ですが、今回のコードは lex で作ったプログラムを単体で動かすため、 main 関数を実装する必要があります。

```lex:mywc.l
%option noyywrap
%{
  int num_lines = 0, num_words =0 ,num_chars = 0;
%}

%%

\n        { ++num_lines; ++num_chars }
[A-Za-z]* ++num_words;
.         ++num_chars;

%%

int main (void) {
  yylex();
  printf("# of lines = %d, # of words = %d # of chars = %d\n", num_lines, num_words, num_chars);
}
```

main 関数の実装はシンプルです。
`yylex()` は lex が提供する関数で、標準入力などから文字列を読み込み、
定義部・規則部で書いた処理を行います。
それによりカウントされた各変数を `printf` で出力しているだけになります。

さて、コードが書けたら早速動かしてみましょう。

まずは、 lex を使って C のコードを生成します。lex コマンドにファイルを渡してやるだけで、 C のソースファイルができます。
今回は -o オプションを渡して生成されるファイル名を mywc.c に指定していますが、デフォルトは lex.yy.c になります。

また、C のソースコードができたら、 cc でコンパイルしてみましょう。

```
$ lex -o mywc.c mywc.l
$ cc -o mywc mywc.c
```

コンパイルすることで実行可能なプログラムができます。

動きを試してみましょう。

```
$ cat mywc.c | mywc
# of lines = 1747, # of words = 6579 # of chars = 17860
```

どうでしょう。それっぽく動きましたか？

```
$ cat mywc.c | wc
    1747    6166   44146
```

本家 wc と動きが地味に違いますが、これは規則部を適当に書いたため(よく見ると分かりますが、 `mywc` は数字が含まれる文字をカウントしていません)ですね。

lex 、flex (lex の GNU 版で、多分今は、大抵こっちが入ってる) についての詳しい説明は
http://www.asahi-net.or.jp/~wg5k-ickw/html/online/flex-2.5.4/flex_toc.html
を見るのが手っ取り早いでしょう。

### yacc で構文解析をしてみる

yacc (yet another compiler compiler) は構文解析器を作るためのツールです。
構文解析器とは与えられたトークンを受け取って、そのトークンの結合をいい感じに解釈する機械です。

まずは簡単に、四則演算を計算するプログラムを書いてみましょう。

```console
$ mybc
> 4 + 10 * 2
24
```

yacc は構文解析器を作るためのツールです。
世の中の幾つかのプログラムにはユーザからの入力を受け付けるものがあります。
例えば、今回作る `mybc` なら `4 + 10 * 2` がユーザからの入力です。
大抵のプログラムではこの入力に一定のルールが設けられています。
例えば `4 + = + 4` みたいな入力は大抵受け付けられません。

yacc では、この「ルール」を以下のような形式で定義していきます。

```yacc
date : year '/' month '/' day ;
```

このルールを言葉にすると次のようになります。

* 日付(date)は、年(year)の後に"/"があり、その次に月(month)があり、その次に"/"があり、最後に日(day)がある

このようなルールや、ルールにマッチするときのアクションなどを定義していくことで構文解析器を作っていきます。
また、いくらルールを書けるとはいえ、正規表現でトークンを抜き出したりするのは過度にルールが複雑になりすぎます。
ですので、たいていの場合は lex で定義した字句解析器と組み合わせて使います。

yacc のプログラムは定義部・規則部・Cコード部の３つのブロックでできており、それぞれの領域は `%%` で区切られます。

```yacc
// ここは定義部

%%

// ここは規則部

%%

// ここはCコード部
```

定義部には yacc 向けのオプション設定や、全体で使われるソースコード、例えば変数や関数の宣言、使用するトークンの優先順位などを書きます。

規則部には構文解析のための規則を書きます。この際、BNFっぽい文法を用いて様々なルールを設定していきます。

Cコード部には、規則部で使う関数の実装を書きます。 main 関数もここに書きます。
また、lex が出力した C 言語のソースファイルを include するのもここです。

まずは規則部から書いていきましょう。

規則部では先ほど上に示したサンプルのような形で、ルールを書いてきます。
ルールは、左側にルール名を書き、コロン(`:`)を挟んで右側に定義を書いていきます。

```
A : BODY ;
```

ルールは同じ名前だけど別の定義を複数書くことができ、その場合はパイプライン `|` で区切ります。
ですので、例えば、

```
A : B C D ;
A : E F ;
A : G ;
```

と

```
A : B C D ;
  | E F ;
  | G ;
```

は同じ意味になります。

別の定義とはどういうことでしょうか？　例えば、日時の定義として `2017/10/21` だけでなく `2017-10-21` にも対応したかったとします。
その場合には、次のように複数の定義を書くことができます。

```
date : year '/' month '/' day
     | year '-' month '-' day ;
```

さて、定義に用いるトークンはあらかじめ定義しておく必要があり、これら定義部で次のように宣言することで行います。

```
%token year month day
```

トークンのうち、開始記号と呼ばれるとても重要なものがあります。
構文中の最も大きくて一般的な記号が開始記号となります。
構文解析器はまずは開始記号からパースを開始します。
開始記号を宣言的に定義することができます。

```
%start symbol
```

終了もあるよ。

定義した文法にはアクションを関連づけることができ、
パースのプロセス中に一致する文法に基づいてアクションを実行することができる。
これらのアクションは値を返すことができるし、アクション中で前のアクションから値を取得することができる
また、必要があれば字句解析器はトークンを返すことができる

アクションは C のステートメントで書くことができ、入出力、他のプログラム呼び出し、外部変数の操作などができます。
また、１つ以上のステートメントを書くことができ、波カッコ `{}` でくくって定義します。以下の例をご覧ください。

```
A : '(' B ')'
  { foo(1, "hogehoge"); }
```

これにより、文法Aを処理する際にこのアクションが呼び出されます。

yacc ではパーサとアクションとのやり取りを簡単にするために `$` で始まる幾つかの疑似変数が用意されています。

例えば、アクションが値を返したい場合には疑似変数 `$$` を使います。例えば、 47 を返したい場合には次のようにします。

```
{ $$ = 47 }
```

アクション中で、前のアクションや字句解析器から値を取り出すためには、疑似変数 `$1`, `$2`, ... を使います。
この変数は、ルールの右側に書かれた定義部分から取得せあれ、左から右に行くにつれて数値が増えていきます。

```
A : B C D ;
```

例えば、上記のようなルールの定義があった場合、 `$2` は C の返す値、 `$3` は D の返す値となります。




```yacc:mybc.y
%%
%%
```

